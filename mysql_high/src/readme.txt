第5章 存储引擎

1.查看存储引擎
show engines;

2.查看默认的存储引擎
select @@default_storage_engine

3.设置默认存储引擎
创建表时通过参数  ENGINE = 引擎名  来指定
修改表的存储引擎通过 ALTER TABLE 表名 ENGINE = 引擎名 来修改

4.引擎介绍
    InnoDB：具备外键支持功能的事务存储引擎
        优点：
            支持事务，支持事务的提交和回滚
            更新、删除操作效率更高
            支持行级锁
        缺点：
            效率差一些、内存要求高(聚簇索引)

    MyISAM：非事务处理存储引擎
        优点：
            访问速度快，对count(*)查询效率高
            适合读和插入为主的应用
        缺点：
            不支持事务，崩溃后无法恢复

第6章 索引的数据结构
1.为什么使用索引
    索引是存储引擎用于快速找到数据记录的一种数据结构
2.索引及其优缺点
    优点：
        降低IO成本
        可以通过唯一索引保证数据的唯一性
        可以加速表和表之间的连接
        可以显著减少查询中分组和排序的时间
    缺点：
        创建和维护索引需要耗费时间
        索引需要占磁盘空间
        会降低更新表的速度
3.InnoDB索引的推演
    在一个页中查找：
        以主键为搜索条件，使用二分
        以其他列作为搜索条件，从最小记录开始依次遍历
    在很多页中查找：
        需要首先定位数据所在的页，然后在所在页中查找记录，在没有索引情况下，需要从第一个页依次查找，十分耗时，因此需要使用索引
    设计索引：
        一步一步迭代为B+树
        为什么B+树通常不超过4层，因为一个页有16kb，4层就可以存放相当多的记录
    常见索引概念：
        聚簇索引：是一种数据存储方式，即所谓的索引即数据，数据即索引，叶子节点存放的是完整的记录
            优点：
                数据访问更快
                节省IO操作
            缺点：
                插入速度严重依赖于插入顺序
                更新主键代价很高
                二级索引访问需要两次索引查找
            限制：
                InnoDB中才有聚簇索引
                表只能有一个聚簇索引
                如果没有定义主键，会选择非空的唯一索引代替，如果没有这样的索引，会隐式的定义一个主键来作为局促索引
                选用有序的顺序id
        二级索引(辅助索引、非聚簇索引)：
            需要一次回表
        联合索引：
            多个字段联合创建索引
    B+树索引的注意事项：
        根页面位置万年不动
        内节点中目录项记录的唯一性
        一个页面最少存储两条记录
4.MyISAM中的索引方案
    同样使用B+树作为索引结构
    MyISAM中没有聚簇索引
    MyISAM索引存储的是地址
    MyISAM一定要回表查询，可以没有主键
5.索引的代价
    空间上：索引都要占有存储空间
    时间上：增删改操作需要维护索引
6.MySQL数据结构选择的合理性：
    磁盘的IO数是至关重要的

    哈希结构查询效率很高，但是不适合范围查询，且没有顺序，无法单独的一个键或者几个索引键进行查询，如果列的重复值较多，会发生Hash冲突，效率降低
    但是InnoDB有自适应哈希索引，如果某个数据经常被访问，当满足一定条件时，会存放到哈希表中

    AVL树的深度也比较深，IO次数也比较多
    为了减少IO，使树更加矮胖，使用B树，但是B树的非叶子节点也会存放数据
    B+树非叶子节点不存放数据，查询效率更稳定，一般只需要1-3次IO

第7章 InnoDB数据存储结构
1.数据库的存储结构：页
    磁盘与内存交互的基本单位：页
    InnoDB页的默认大小为16KB

    页的上层概念是区，一个区有64个页，一个区大小为1MB
    区的上层结构是段，段是数据库中的分配单位
    段的上层结构是表空间

2.页的内部结构
    按类型划分：
        数据页(保存B+树节点)，系统页，Undo页，事务数据页
    页的结构：
        文件头 38字节
        页头 56字节
        最大和最小记录 26字节
        用户记录 不确定
        空闲记录 不确定
        页目录 不确定
        文件尾 8字节

    第一部分：文件头和文件尾
        文件头：
            4字节 页的校验和 检测数据是否一致(当内存和磁盘进行IO操作时，如果因为某些原因没有能够正常完成，则头尾的校验和会不一致，就可以检测出数据不一致)
            4字节 页号 通过页号唯一定位页号
            4字节 上一页的页号
            4字节 下一页的页号
            8字节 页面被最后修改时对应的日志序列位置
            2字节 页的类型 主要由日志页、索引页、系统页、Undo日志页等
            8字节 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 同样也是为了校验页的完整性
            4字节 页属于的表空间
        文件尾：
            4字节 校验和
            4字节 页面被最后修改时对应的日志序列位置(LSN)
    第二部分：空闲空间，用户记录，最大最小记录
        空间空间，按照指定行格式存储到用户记录中
        用户空间，按照指定行格式存储数据
        最大最小记录，都是由13个字节组成，前5个字节是记录头信息(详见Compact行格式)，后8个字节是固定部分，分别代表infimum和supremum
    第三部分：页目录和页头
        页目录 方便在页中快速查找到记录
            将所有记录分为几个组
            第一组，就是最小记录所在的组，只有1条记录。最后一组是最大记录所在组，会有1-8条记录，其余4-8条之间，目的是让其余的组尽量平分
            每组中最后一条记录的头信息中会存储一共多少小记录，作为n_owned字段
            页目录用来存储每组最后一条记录的地址偏移量，这个偏移量也称为槽(slot)
        页头 56字节
            2字节 PAGE_N_DIR_SLOTS 在页目录中的槽数量
            2字节 PAGE_HEAP_TOP 还未使用的空间最小地址，也就是说该地址之后就是空闲空间
            2字节 PAGE_N_HEAP 本页中的记录和数量(包括最小和最大记录以及标记为删除的记录)
            2字节 PAGE_FREE 第一个已经标记为删除的记录地址
            2字节 PAGE_GARBAGE 已删除记录占用的字节数
            2字节 PAGE_LAST_INSERT 最后插入记录的位置
            2字节 PAGE_DIRECTION 记录插入的方向 如果新插入的记录主键值比上一条记录的大，就说插入方向是右边，反之就是左边
            2字节 PAGE_N_DIRECTION 一个方向连续插入的记录数量
            2字节 PAGE_N_RECS 该页中记录的数量(不包括最小和最大记录以及被标记位删除的记录)
            8字节 PAGE_MAX_TRX_ID 修改当前页的最大事务ID，该值仅在二级索引中定义
            2字节 PAGE_LEVEL 当前页在B+树中所处的层级
            8字节 PAGE_INDEX_ID 索引ID，表示当前页属于哪个索引
            10字节 PAGE_BTR_SEG_LEAF B+树叶字段的头部信息，仅在B+树的Root页定义
            10字节 PAGE_BTR_SEG_TOP B+树非叶字段的头部信息，仅在B+树的Root页定义

3.InnoDB行格式：通过 SELECT @@innodb_default_row_format; 查看

    Compact行格式：
        变长字段长度列表 记录变长字段实际上存储的长度
        NULL值列表 将可以为NULL的列统一管理
        记录头信息(5字节)：
            delete_mask 标记当前记录是否被删除 删除记录实际上只是做一个标记，所有被删除的记录会组成一个垃圾链表，这个链表占用的空间就是可重用空间
            min_rec_mask 每层非叶子节点的最小记录都会添加该标记
            record_type 记录类型：0表示普通记录，1表示非叶子节点记录，2表示最小记录，3表示最大记录
            heap_no 当前记录在本页中的位置 0和1分别表示最小记录和最大记录，由MySQL自动添加，不用手动插入，因此也称为伪记录或者虚拟记录
            n_owned 该组元素的个数
            next_record 从当前记录真实数据到下一条记录真实数据的地址偏移量
        记录的真实数据
            除了定义的数据之外，还有三个隐藏列
            6字节 DB_ROW_ID 如果没有手动定义主键，就会选取一个唯一键作为主键，如果没有唯一键，就用row_id作为主键
            6字节 DB_TRX_ID 事务ID
            7字节 DB_ROLL_PTR 回滚指针
    Dynamic和Compressed行格式
        行溢出：字段存储空间超过页的大小，就会出现行溢出，在Compact和Redundant行格式中，就会进行分页存储
        Dynamic和Compressed遇到行溢出时，会将所有数据都放在溢出页中
        Compressed的行数据会以zlib的算法进行压缩
    Redundant行格式
        字段长度偏移列表 会将该条记录所有列(包括隐藏列)的长度信息都按照逆序存储到字段长度偏移列表
        记录头信息(6字节)：
            相比Compact，多了n_field和1byte_offs_flag两个属性，没有record_type属性
        真实数据

4.区、段与碎片区
    因为随机IO十分慢，因此尽量要顺序IO，所以引入区，区内存储的是物理位置上连续的64个页

    B+树只有叶子节点存放数据，但是页内可能存放叶子节点也可能存放非叶子节点，为了提高效率，将叶子节点的集合划分为一个段，非叶子结点的集合也分为一个段

    假如表中只有很少的数据，只有几条记录，会十分浪费空间，为了解决这个问题，引入了碎片区，碎片区的页可以用于不同的目的，碎片区直属于表空间
        在之后为某段分配存储空间的策略：
            在刚开始插入数据时，由于数据量较小，所以是以碎片区的单个页面为单位存储的
            当段已经占用了32个碎片区之后，就以完整的区为单位来分配存储空间

    区的分类：
        空间区(FREE)：没有用到这个区内的任何页
        有剩余空间的碎片区(FREE_FRAG)：表示碎片区中海油可用的页面
        没有剩余空间的碎片区(FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面
        附属于某段的区(FSEG)：每个索引都可以分为叶子节点段和非叶子节点段

5.表空间
    可以看做是InnoDB存储引擎结构的最高层，所有数据都存放在表空间中

    独立表空间：
        每张表都有独立的表空间
        使用命令 show variables like 'innodb_file_per_table'; 查看表空间类型

    系统表空间：
        整个MySQL进程只有一个系统表空间，记录有关整个系统信息的页面

第8章 索引的创建与设计原则
    1.索引的声明与使用
        分类：
            功能逻辑：普通索引、唯一索引、主键索引、全文索引
            物理实现：聚簇索引、非聚簇索引
            作用字段个数：单列索引、联合索引

        普通索引：没有附加任何限制条件
        唯一索引：声明UNIQUE参数的字段，一个表内可以有多个唯一索引
        主键索引：特殊的唯一性索引，一个表内最多只有一个主键索引
        单列索引：单个字段上创建的索引，一个表可以有多个单列索引
        多列索引(联合索引)：多个字段组合上创建一个索引，使用遵循最左前缀原则
        全文索引：适合大型数据集

        索引的创建：
            1.创建表时添加索引(隐式)
                在声明有主键约束、唯一性约束、外键约束的字段上，会自动的添加相关的索引

                创建普通索引(显式)
                    CREATE TABLE table_name [col_name data_type]
                    [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]

                    性能分析工具，EXPLAIN + SQL语句，可以分析是否使用到索引
                创建唯一索引(显式)
                    UNIQUE INDEX index_name(col_name)
                创建主键索引(隐式)
                    通过定义主键约束来添加主键索引
                创建联合索引(显式)
                    显式声明联合索引
                创建全文索引(显式)
                    只能在char、varchar、text列创建
                创建空间索引(显式)

            2.表已经创建成功后添加索引
                ALTER TABLE ... ADD ... INDEX ...
                CREATE INDEX ... ON ...

        索引的删除
            ALTER TABLE ... DROP INDEX ...
            DROP INDEX ... ON ...
            删除联合索引的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除，如果所有列都删除，则整个索引也会删除

    2.MySQL8.0索引新特性
        支持降序索引，可以进行反向扫描
        隐藏索引，将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引，确认设置为隐藏后系统不受任何影响，就可以彻底删除索引(软删除)

    3.索引的设计原则
        索引设计不合理或者缺少索引都会造成性能障碍

        哪些情况适合创建索引
            1.字段的数值有唯一性索引
            2.频繁作为WHERE查询条件的字段
            3.经常GROUP BY和ORDER BY的列
                如果同时需要GROUP BY和ORDER BY，建立联合索引，将GROUP BY的字段写前面，ORDER BY的写后面
            4.UPDATE、DELETE的WHERE条件列
                因为我们需要先根据WHERE条件列检索出来记录再进行删除，因此对WHERE字段添加索引能大幅提升效率
                但是需要注意的是：只有更新的字段是非索引字段，提升的效率就会更明显，这是因为非索引字段更新不需要维护索引
            5.DISTINCT字段
            6.多表JOIN连接时，创建索引的注意事项
                连接表的数量尽量不要超过3张
                对WHERE条件创建索引
                对连接的字段创建索引，但是需要注意该字段在多张表的类型必须一致
            7.使用列的类型小的创建索引
                类型大小指的是数据范围的大小
            8.使用字符串前缀创建索引
                使用字符串前缀作为索引能够大幅节省空间
                但是无法使用索引排序，因为看不到后续的字符，可能出现前缀相同，后面其他字符不同的情况
            9.区分度高(散列度高)的列适合作为索引
            10.使用最频繁的列放在联合索引的最左侧
            11.在多个字段都要创建索引的情况下，联合索引优于单值索引

        单张表的索引数量建议不超过6个，因为索引也会占用空间且会影响增删改等语句的性能，优化器在优化时也会分析较多的索引会耗费时间

    4.哪些情况不适合创建索引
        1.WHERE中使用不到的字段
        2.数据量小的表最好不要使用索引
        3.有大量重复数据的列上不要建立索引
            当重复度高于10%的时候也不需要使用索引
        4.避免对经常更新的表创建过多的索引
        5.不建议用无序的值作为索引
        6.删除不再使用或者很少使用的索引
        7.不要定义冗余或重复的索引

第9章 性能分析工具的使用
    数据库调优的目标：响应时间更快、吞吐量更大
    1.数据库服务器的优化步骤
        观察服务器状态：
            是否存在周期性波动，如果存在，加缓存或更改缓存失效策略
            如果不存在周期性波动或者仍然有不规则延迟或卡顿，开启慢查询，使用EXPLAIN，SHOW PROFILING查看是SQL执行时间长还是等待时间长
                如果是SQL等待时间长，调优服务器参数
                如果是SQL执行时间长，需要索引设计优化，JOIN表优化，表设计优化
            如果还没有解决，查看是否达到SQL查询的瓶颈，如果没有，重新检查，否则读写分离、分库分表
    2.查看系统性能参数
        SHOW [GLOBAL | SESSION] STATUS LIKE '参数';
        一些常用的性能参数如下：
            Connections：连接MySQL服务器的次数
            Uptime：MySQL服务器的上线时间
            Slow_queries：慢查询的次数
            Innodb_rows_read：Select查询返回的行数
            Innodb_rows_inserted：执行INSERT操作插入的行数
            Innodb_rows_updated：执行UPDATE操作修改的行数
            Innodb_rows_deleted：执行DELETE操作删除的行数
            Com_select：查询操作的次数
            Com_insert：插入操作的次数，对于批量插入的INSERT操作，只累加一次
            Com_update：更新操作的次数
            Com_delete：删除操作的次数
    3.统计SQL查询的成本：last_query_cost
        这个参数是查看使用了多少个数据页的查询
        但是并不能代表实际的效率，有时候数据页增加了不少但是查询时间并没有增加多少，因为有缓冲池的作用
        使用场景：在多种查询方式可选时，对于比较开销很有用
            位置决定效率：如果页就在缓冲池中，效率就是最高的
            批量决定效率：如果单页随机读，则效率很低
    4.定位执行慢的SQL：慢查询日志
        超过参数long_query_time值的SQL就会记录到慢查询日志中，默认为10s
        默认是没有开启慢查询日志的，如果不是调优需要时，不建议开启

        开启慢查询日志参数
            slow_query_log参数设置开启慢查询日志
            开启后，日志保存在slow_query_log_file保存的路径中
            修改long_query_time阈值
        查看慢查询数据
            SHOW GLOBAL STATUS LIKE '%Slow_queries';
        慢查询日志分析工具
            查看帮助信息
            mysqldumpslow --help
        关闭慢查询日志
            和开启方式一致
        删除慢查询日志
            和正常删除文件一致
            重建日志文件：
                mysqladmin -uroot -p flush-logs slow
    5.查看SQL执行成本：SHOW PROFILE
        如果在show profile中出现了以下任何一条，则sql语句需要优化
            converting HEAP to MyISAM：查询结果太大，内存不够
            Creating tmp table：创建临时表，先拷贝数据到临时表，用完再删除
            Copying to tmp table on disk：把内存中临时表赋值到磁盘上，警惕！
            locked
        show profile命令将被弃用，可以通过information_schema中profiling中查看
    6.分析查询语句：EXPLAIN
        可以用EXPLAIN或DESCRIBE工具做针对性的分析查询语句
            id 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id
                id如果相同，可以认为是一组，从上往下顺序执行
                在所有组中，id值越大，优先级越高越先执行
                id的每个值代表一趟查询，越少越好
            select_type SELECT关键字对应的那个查询的类型
                确定小查询在大查询中扮演一个什么角色
            table 表名
            partitions 匹配的分区信息
            type 针对单表的访问方法，从上到下效率依次减小
                system：表中只有一条记录，并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么该表的访问方法就是system
                const：根据主键或者唯一二级索引列与常数进行等值匹配时，就是const
                eq_ref：如果被驱动表是通过主键或者唯一耳机索引列等值匹配的方式访问(如果该主键或者唯一二级索引是联合索引，所有的索引列都必须进行等值比较)，则为eq_ref
                ref：当普通二级索引与常量进行等值匹配
                fulltext
                ref_or_null：如果等值匹配时该索引列的值也可以为null时
                index_merge：or两边的字段都使用索引进行查询
                unique_subquery：在一些包含IN子查询中，如果优化器决定将IN子查询转换为EXISTS子查询，而且子查询可以使用到主键进行等值匹配
                index_subquery
                range：索引获取范围区间的记录
                index：索引覆盖，但是需要扫描全部的索引记录
                all：全表扫描
            possible_keys 可能用到的索引
            key 实际上使用的索引
            key_len 实际使用到的索引长度(单位：字节)，检查是否充分用上索引，值越大越好，主要针对联合索引有一定参考意义
            ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息
            rows 预估的需要读取的记录条数
            filtered 某个表经过搜索条件过滤后剩余记录条数的百分比
                更关注在连接查询中驱动表对应的执行计划记录的filtered值，决定了被驱动表要执行的次数(rows * filtered)
            Extra 一些额外信息
                更准确的理解MySQL到底将如何执行给定的查询语句
                No tables used：当查询语句没有FROM时
                Impossible where：当WHERE语句永远为FALSE时
                Using where：当使用全表扫描并且WHERE语句中有针对该表的搜索条件时，当使用索引来访问并且WHERE语句中有盖索引包含的列之外的其他搜索条件时
                No matching min/max row：当查询有MIN或MAX聚合函数，但是没有符合WHERE搜索条件的记录时
                Using index：查询列表以及搜索条件中指包含属于某个索引的列，也就是可以使用覆盖索引时
                Using index condition：虽然出现了索引列，但是却不能使用到索引
                Using join buffer：在连接查询时，当驱动表不能有效利用索引加快访问速度，MySQL会分配join buffer的内存块来加速查询速度
                Not exists：当使用左外连接时，如果WHERE子句包含要求被驱动表的某列等于NULL的搜索条件，而且那列又是不允许存储NULL的
                Using union：用union索引合并的方式查询
                Using intersect：使用intersect索引
                Using sort_union：使用sort_union索引合并的方式查询
                Zero limit：limit参数为0时
                Using filesort：需要使用文件排序的方式执行查询
                    无法用到索引，只能再内存中或者磁盘中进行排序上进行排序时称为文件排序
                Using temporary：需要建立内部临时表来查询时

        EXPLAIN不考虑各种Cache
        EXPLAIN不能显示MySQL在查询时所作的优化工作
        EXPLAIN不会告诉关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
        部分信息是估算的，并非精确值

    7.EXPLAIN的进一步使用
        EXPLAIN可以输出四种格式：传统格式、JSON格式、TREE格式以及可视化输出
        EXPLAIN FORMAT=JSON|TREE ...

        SHOW WARNINGS
            在EXPLAIN之后，可以使用这个语句查看一些扩展信息，MESSAGE就是优化器重写后的语句

