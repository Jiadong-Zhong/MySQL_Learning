第5章 存储引擎

1.查看存储引擎
show engines;

2.查看默认的存储引擎
select @@default_storage_engine

3.设置默认存储引擎
创建表时通过参数  ENGINE = 引擎名  来指定
修改表的存储引擎通过 ALTER TABLE 表名 ENGINE = 引擎名 来修改

4.引擎介绍
    InnoDB：具备外键支持功能的事务存储引擎
        优点：
            支持事务，支持事务的提交和回滚
            更新、删除操作效率更高
            支持行级锁
        缺点：
            效率差一些、内存要求高(聚簇索引)

    MyISAM：非事务处理存储引擎
        优点：
            访问速度快，对count(*)查询效率高
            适合读和插入为主的应用
        缺点：
            不支持事务，崩溃后无法恢复

第6章 索引的数据结构
1.为什么使用索引
    索引是存储引擎用于快速找到数据记录的一种数据结构
2.索引及其优缺点
    优点：
        降低IO成本
        可以通过唯一索引保证数据的唯一性
        可以加速表和表之间的连接
        可以显著减少查询中分组和排序的时间
    缺点：
        创建和维护索引需要耗费时间
        索引需要占磁盘空间
        会降低更新表的速度
3.InnoDB索引的推演
    在一个页中查找：
        以主键为搜索条件，使用二分
        以其他列作为搜索条件，从最小记录开始依次遍历
    在很多页中查找：
        需要首先定位数据所在的页，然后在所在页中查找记录，在没有索引情况下，需要从第一个页依次查找，十分耗时，因此需要使用索引
    设计索引：
        一步一步迭代为B+树
        为什么B+树通常不超过4层，因为一个页有16kb，4层就可以存放相当多的记录
    常见索引概念：
        聚簇索引：是一种数据存储方式，即所谓的索引即数据，数据即索引，叶子节点存放的是完整的记录
            优点：
                数据访问更快
                节省IO操作
            缺点：
                插入速度严重依赖于插入顺序
                更新主键代价很高
                二级索引访问需要两次索引查找
            限制：
                InnoDB中才有聚簇索引
                表只能有一个聚簇索引
                如果没有定义主键，会选择非空的唯一索引代替，如果没有这样的索引，会隐式的定义一个主键来作为局促索引
                选用有序的顺序id
        二级索引(辅助索引、非聚簇索引)：
            需要一次回表
        联合索引：
            多个字段联合创建索引
    B+树索引的注意事项：
        根页面位置万年不动
        内节点中目录项记录的唯一性
        一个页面最少存储两条记录
4.MyISAM中的索引方案
    同样使用B+树作为索引结构
    MyISAM中没有聚簇索引
    MyISAM索引存储的是地址
    MyISAM一定要回表查询，可以没有主键
5.索引的代价
    空间上：索引都要占有存储空间
    时间上：增删改操作需要维护索引
6.MySQL数据结构选择的合理性：
    磁盘的IO数是至关重要的

    哈希结构查询效率很高，但是不适合范围查询，且没有顺序，无法单独的一个键或者几个索引键进行查询，如果列的重复值较多，会发生Hash冲突，效率降低
    但是InnoDB有自适应哈希索引，如果某个数据经常被访问，当满足一定条件时，会存放到哈希表中

    AVL树的深度也比较深，IO次数也比较多
    为了减少IO，使树更加矮胖，使用B树，但是B树的非叶子节点也会存放数据
    B+树非叶子节点不存放数据，查询效率更稳定，一般只需要1-3次IO

第7章 InnoDB数据存储结构
1.数据库的存储结构：页
    磁盘与内存交互的基本单位：页
    InnoDB页的默认大小为16KB

    页的上层概念是区，一个区有64个页，一个区大小为1MB
    区的上层结构是段，段是数据库中的分配单位
    段的上层结构是表空间

2.页的内部结构
    按类型划分：
        数据页(保存B+树节点)，系统页，Undo页，事务数据页
    页的结构：
        文件头 38字节
        页头 56字节
        最大和最小记录 26字节
        用户记录 不确定
        空闲记录 不确定
        页目录 不确定
        文件尾 8字节

    第一部分：文件头和文件尾
        文件头：
            4字节 页的校验和 检测数据是否一致(当内存和磁盘进行IO操作时，如果因为某些原因没有能够正常完成，则头尾的校验和会不一致，就可以检测出数据不一致)
            4字节 页号 通过页号唯一定位页号
            4字节 上一页的页号
            4字节 下一页的页号
            8字节 页面被最后修改时对应的日志序列位置
            2字节 页的类型 主要由日志页、索引页、系统页、Undo日志页等
            8字节 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 同样也是为了校验页的完整性
            4字节 页属于的表空间
        文件尾：
            4字节 校验和
            4字节 页面被最后修改时对应的日志序列位置(LSN)
    第二部分：空闲空间，用户记录，最大最小记录
        空间空间，按照指定行格式存储到用户记录中
        用户空间，按照指定行格式存储数据
        最大最小记录，都是由13个字节组成，前5个字节是记录头信息(详见Compact行格式)，后8个字节是固定部分，分别代表infimum和supremum
    第三部分：页目录和页头
        页目录 方便在页中快速查找到记录
            将所有记录分为几个组
            第一组，就是最小记录所在的组，只有1条记录。最后一组是最大记录所在组，会有1-8条记录，其余4-8条之间，目的是让其余的组尽量平分
            每组中最后一条记录的头信息中会存储一共多少小记录，作为n_owned字段
            页目录用来存储每组最后一条记录的地址偏移量，这个偏移量也称为槽(slot)
        页头 56字节
            2字节 PAGE_N_DIR_SLOTS 在页目录中的槽数量
            2字节 PAGE_HEAP_TOP 还未使用的空间最小地址，也就是说该地址之后就是空闲空间
            2字节 PAGE_N_HEAP 本页中的记录和数量(包括最小和最大记录以及标记为删除的记录)
            2字节 PAGE_FREE 第一个已经标记为删除的记录地址
            2字节 PAGE_GARBAGE 已删除记录占用的字节数
            2字节 PAGE_LAST_INSERT 最后插入记录的位置
            2字节 PAGE_DIRECTION 记录插入的方向 如果新插入的记录主键值比上一条记录的大，就说插入方向是右边，反之就是左边
            2字节 PAGE_N_DIRECTION 一个方向连续插入的记录数量
            2字节 PAGE_N_RECS 该页中记录的数量(不包括最小和最大记录以及被标记位删除的记录)
            8字节 PAGE_MAX_TRX_ID 修改当前页的最大事务ID，该值仅在二级索引中定义
            2字节 PAGE_LEVEL 当前页在B+树中所处的层级
            8字节 PAGE_INDEX_ID 索引ID，表示当前页属于哪个索引
            10字节 PAGE_BTR_SEG_LEAF B+树叶字段的头部信息，仅在B+树的Root页定义
            10字节 PAGE_BTR_SEG_TOP B+树非叶字段的头部信息，仅在B+树的Root页定义

3.InnoDB行格式：通过 SELECT @@innodb_default_row_format; 查看

    Compact行格式：
        变长字段长度列表 记录变长字段实际上存储的长度
        NULL值列表 将可以为NULL的列统一管理
        记录头信息(5字节)：
            delete_mask 标记当前记录是否被删除 删除记录实际上只是做一个标记，所有被删除的记录会组成一个垃圾链表，这个链表占用的空间就是可重用空间
            min_rec_mask 每层非叶子节点的最小记录都会添加该标记
            record_type 记录类型：0表示普通记录，1表示非叶子节点记录，2表示最小记录，3表示最大记录
            heap_no 当前记录在本页中的位置 0和1分别表示最小记录和最大记录，由MySQL自动添加，不用手动插入，因此也称为伪记录或者虚拟记录
            n_owned 该组元素的个数
            next_record 从当前记录真实数据到下一条记录真实数据的地址偏移量
        记录的真实数据
            除了定义的数据之外，还有三个隐藏列
            6字节 DB_ROW_ID 如果没有手动定义主键，就会选取一个唯一键作为主键，如果没有唯一键，就用row_id作为主键
            6字节 DB_TRX_ID 事务ID
            7字节 DB_ROLL_PTR 回滚指针
    Dynamic和Compressed行格式
        行溢出：字段存储空间超过页的大小，就会出现行溢出，在Compact和Redundant行格式中，就会进行分页存储
        Dynamic和Compressed遇到行溢出时，会将所有数据都放在溢出页中
        Compressed的行数据会以zlib的算法进行压缩
    Redundant行格式
        字段长度偏移列表 会将该条记录所有列(包括隐藏列)的长度信息都按照逆序存储到字段长度偏移列表
        记录头信息(6字节)：
            相比Compact，多了n_field和1byte_offs_flag两个属性，没有record_type属性
        真实数据